{"version":3,"file":"static/js/921.852fcbf4.chunk.js","mappings":"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","sources":["../webpack/bootstrap","../webpack/runtime/define property getters","../webpack/runtime/hasOwnProperty shorthand","kooljs/worker.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var finished = []\nvar fps = 33.33\nvar resultsnew,signal,controller = null\nasync function sleep(milliseconds) {\n    return new Promise(resolve => setTimeout(resolve, milliseconds))\n}\n// ----------------------------------------> CLASS DEFINITIONS <--\nclass Lerp {\n    constructor() {\n        this.trigger_start = undefined\n        this.trigger_target = undefined\n        this.trigger_type = undefined\n        this.type = undefined\n        this.min = undefined\n        this.max = undefined\n        this.type = undefined\n        this.duration = undefined\n        this.render_interval = undefined\n        this.delay_delta = undefined\n        this.delay = undefined\n        this.progress = undefined\n        this.smoothstep = undefined\n        this.lerp_chain_start=undefined\n        this.activelist = []\n        this.results = []\n        this.last_value=[]\n    }\n    reset(id) {\n        // if (type > 0) {\n        //     this.progress[id] = 0\n        // }\n        if (this.activelist.includes(id) == false) {\n            this.results = new Float32Array(this.results.length + 1)\n            this.activelist.push(id)\n        }\n    }\n    update(id, values) {\n        Object.entries(values).map((val) => {\n            this[val[0]][id] = val[1]\n        })     \n        start_animations(id)\n    }\n  get(index){//this function is for custom callback functions. its used for getting other values via index\n        return this.last_value[index]\n        }\n}\nclass LerpChain{\n    constructor(){\n        this.buffer=undefined\n        this.progress=undefined\n        this.lengths=undefined\n    }\n    update_progress(id){\n        const step=this.progress[id]\n        if(step==this.lengths[id]-1){\n            this.reset(id)\n            return true\n        }\n        else{\n            \n            lerp_registry.min[id]=this.buffer[lerp_registry.lerp_chain_start[id]+this.progress[id]]\n            lerp_registry.max[id]=this.buffer[lerp_registry.lerp_chain_start[id]+this.progress[id]+1]\n            this.progress[id]+=1\n            lerp_registry.progress[id]=0\n            return(false)\n        }\n}\nreset(id){\n    lerp_registry.min[id]=this.buffer[lerp_registry.lerp_chain_start[id]]\n    lerp_registry.max[id]=this.buffer[lerp_registry.lerp_chain_start[id]+1]\n    lerp_registry.progress[id]=0\n    this.progress[id]=1\n}\n}\nclass Callback {\n    constructor() {\n        // hier einach -1 für keine weights setzen, \n        // oder eine liste erstellen die nur die elemente enthält die eine condi haben\n        this.callback=undefined\n        this.threshold=undefined\n    }\n}\nclass Constant {\n    constructor(matrices,numbers){\n        this.matrix=undefined\n        this.number=undefined\n    }\n   update(type, id, value){\n        constant_registry[type][id]=value\n    }\n    get(type,index){\n        return constant_registry[type][index]\n        }\n}\n\n// ----------------------------------------> DATABASE <--\nconst lerp_registry = new Lerp()\nconst constant_registry = new Constant()\nconst condi = new Callback()\nconst lerpChain_registry = new LerpChain()\n\n// ----------------------------------------> ANIMATION <--\nvar v,t\nfunction smoothLerp(min, max, v, amount) {\n    t = smoothstep(v)\n  //  t=(t*amount)/t\n    return (max * t) + (min * (1 - t))\n}\nfunction smoothstep(x) {\n    return x * x * (3 - 2 * x);\n}\nasync function animate() {\n    lerp_registry.activelist.reverse().map((val, index) => {\n        //checking if the element is finished and needs to be deleted\n        if (lerp_registry.progress[val] < lerp_registry.duration[val]) {\n            //waiting for delay\n            if (lerp_registry.delay_delta[val] < lerp_registry.delay[val]) {\n                lerp_registry.delay_delta[val] += 1\n            }\n            else {\n                //increment progress\n                lerp_registry.progress[val] += 1\n                // First for registry.trigger_target[val]: If this value is null or undefined, 0 is used instead.\n                // Then again for registry.type[...]: Similarly, 0 is used if the index is null or undefined.\n                if (lerp_registry.trigger_target[val] ?? 0 >= lerp_registry.trigger_start[val]) {\n                    lerp_registry.reset(lerp_registry.trigger_target[val] ?? 0, lerp_registry.type[lerp_registry.trigger_target[val] ?? 0])\n                }\n                if (lerp_registry.progress[val] % lerp_registry.render_interval[val] == 0) {\n                    // v = normalized time delta\n                    v = lerp_registry.progress[val] / lerp_registry.duration[val];\n\n                    t= smoothLerp(lerp_registry.min[val], lerp_registry.max[val], v,lerp_registry.smoothstep[val])\n                    //t += perform callback if there is one\n                    //t = condi.callback.get(val)?.(val, t) ?? undefined; //  Null-Coalescing-Operator -- if callback not undefined then use and process the value t for callback\n                    t=condi.callback.get(val)!=undefined?condi.callback.get(val)(val,t,v):t//?.(val, t) ?? undefined;\n                    \n                    //adding the lastvalue for static \n                    lerp_registry.last_value[val] = lerp_registry.results[index] =t // the length of results is equal to the length of activelists\n                }\n                console.log(`\"id\" ${val} \"progres:\" ${lerp_registry.progress[val]} \"res:\" ${lerp_registry.results[index]}`)\n                // at this point the element that is finished can also get removed\n            }\n        } else {\n            if(lerp_registry.lerp_chain_start[val]!=undefined&&lerpChain_registry.update_progress(val)==true){\n            lerp_registry.delay_delta[val] = 0\n            lerp_registry.progress[val] = 0\n            finished.push(val);\n        }\n        }\n    })\n}\nasync function animateLoop() {\n    controller = new AbortController();\n    signal = controller.signal;\n    while (true) {\n        await sleep(fps)\n        if (signal.aborted == true) {\n            break\n        }\n        if (lerp_registry.activelist[\"length\"] > 0) {\n            finished = []\n            // eslint-disable-next-line no-loop-func\n            animate().then(() => {\n                if (lerp_registry.results[\"length\"] > 0) {\n                    // hier promise einabuen\n                    if (finished[\"length\"] > 0) {\n                        fin()\n                    }\n                    render()\n                }\n\n            })\n        }\n    }\n}\n\n// ----------------------------------------> WORKER UTILS <--\n\nfunction fin() {\n    postMessage({\n        message: \"finish\",\n        results: lerp_registry.results,\n        result_indices: lerp_registry.activelist\n    });\n    resultsnew = new Float32Array(lerp_registry.results.length - finished.length);\n    lerp_registry.activelist = lerp_registry.activelist.filter((index) => {\n        if (!finished.includes(index)) {\n            resultsnew[index] = lerp_registry.results[index];\n            return true; \n        }\n        return false; \n    });\n    if (lerp_registry.activelist[\"length\"] == 0) {\n        stop_loop()\n    }\n    lerp_registry.results = resultsnew\n    finished = []\n}\n\n\nfunction start_loop() {\n    animateLoop()\n}\n\nfunction stop_loop() {\n    if (controller !== null) {\n        controller.abort()\n        controller = null\n    }\n}\n\n\nfunction start_animations(indices){\n    indices.map((id)=>{\n        if(lerp_registry.lerp_chain_start[id]!=undefined){\n            lerpChain_registry.reset(id)\n        }\n        if (lerp_registry.activelist.includes(id) == false) {\n            lerp_registry.results = new Float32Array(lerp_registry.results.length + 1)\n            lerp_registry.activelist.push(id)\n        }\n    if (controller == null) {\n        start_loop()\n    } else {\n        stop_loop()\n        start_loop()\n    }\n    })\n}\nfunction change_framerate(fps_new) {\n    fps = fps_new\n}\nfunction init(lerps, lerpChains, constants, condi_new, springs) {\n    condi.callback=new Map()\n    condi_new.get(\"callback\").forEach((val,ke)=>{\n          condi.callback.set(ke,eval(val))\n    })\n    lerpChains.forEach((arr,name)=>{\n        if(name!=\"buffer\"){\n            lerpChain_registry[name]=arr\n        }\n        else{\n            lerpChain_registry[name]=new Float32Array(arr)\n        }\n    })\n    condi.threshold= new Float32Array(condi_new.threshold)\n    lerps.forEach((array, name) => {\n            lerp_registry[name] = new Float32Array(array)\n    })\n    if(constants.get(\"matrix\")!=undefined){\n    constants.get(\"matrix\").forEach((val)=>{\n        constant_registry.matrix.push(new Float32Array(val))\n    })\n}\n    if(constants.get(\"number\")!=undefined){\n            constant_registry.number=(new Float32Array(constants.get(\"number\")))\n    }\n    lerp_registry.last_value=new Float32Array(lerp_registry.min)\n    lerp_registry.activelist = []\n}\n\n// ----------------------------------------> EVENTS <--\nasync function render() {\n    postMessage({ message: \"render\", results: lerp_registry.results, result_indices: lerp_registry.activelist })\n}\nfunction trigger() {\n    postMessage({ message: \"trigger\", results: lerp_registry.results, result_indices: lerp_registry.activelist })\n}\nonmessage = (event) => {\n    // eslint-disable-next-line default-case\n    switch (event.data.method) {\n        case 'init':\n            init(event.data.data, event.data.chain_map, event.data.constants, event.data.callback_map,event.data.spring_map,);\n            break;\n        case 'update_lerp':\n            lerp_registry.update(event.data.id, event.data.values);\n            break;\n        case \"update_chain\":\n                    lerpChain_registry.buffer=new Float32Array(event.data.buffer)\n                    lerpChain_registry.lengths[event.data.id]=event.data.newLength\n                    lerpChain_registry.reset(event.data.id)\n            break\n        case 'update_constant':\n            constant_registry.update(event.data.type, event.data.id,event.data.value);\n            break;\n        case 'start_loop':\n            change_framerate(event.data.fps)\n            start_loop();\n            break;\n        case 'stop':\n            stop_loop();\n            break;\n        case 'change_framerate':\n            change_framerate(event.data.fps_new);\n            break;\n        case 'start':\n            start_animations(event.data.indices);\n            break;\n    }\n};\nfunction get_lerp_value(id){return lerp_registry.get(id)}\nfunction reset_lerp(id){return lerp_registry.reset_lerp(id)}\nexport {get_lerp_value,reset_lerp,set,change_framerate}\n\n// ----------------------------------------> REQUIRES IMPLEMENTATION <--\nfunction set(id){\n    //activelist,results,lastvalue,min/max\n}\nclass Spring{\n    constructor(elements,duration,spring_tension,spring_whatever,){\n            this.elements=elements\n            this.duration=duration\n            this.spring_tension=spring_tension\n    \n    }\n    }\n//dijkstra algo für matrix\nfunction shortest_path(){\n\n}\n// k nearest neigbor for matrix (not sure if also for lerp)\nfunction knn(){\n\n}\n//matrix and callback for lerp\nfunction convex_hull(){\n\n}\nfunction spring(){\n\n}\n\n\n\n//v = Math.floor(registry.progress[val] / registry.duration[val]);\n\n\n\n// function calculateSpringAnimation(matrix, params) {\n//     const { mass, tension, friction, bounce, damping, decay, duration, velocities } = params;\n  \n//     return matrix.map((value, index) => {\n//       const initialValue = value;\n//       const targetValue = params.targetValues ? params.targetValues[index] : initialValue;\n      \n//       const k = 2 * Math.PI * Math.sqrt(tension / mass);\n//       const zeta = damping / (2 * mass);\n//       const omega = k * Math.sqrt(1 - zeta * zeta);\n  \n//       return (t) => {\n//         const x = targetValue - initialValue;\n//         const theta = omega * t;\n  \n//         let y;\n//         if (zeta < 1) {\n//           // Unter- oder kritisch gedämpft\n//           y = x * Math.exp(-zeta * theta) * (Math.cos(theta) + (zeta / omega) * Math.sin(theta));\n//         } else {\n//           // Überdämpft\n//           y = x * Math.exp(-omega * t);\n//         }\n  \n//         // Bounce-Effekt hinzufügen\n//         const bounceFactor = Math.pow(0.9, t / duration);\n//         y *= bounceFactor;\n  \n//         // Auslaufwert berücksichtigen\n//         return targetValue + (y - targetValue) * Math.exp(-decay * t);\n//       };\n//     });\n//   }\n  \n//   // Beispielaufruf:\n//   const matrix = [10, 20, 30, 40, 50];\n//   const params = {\n//     mass: 0.5,\n//     tension: 100,\n//     friction: 0.05,\n//     bounce: 0.9,\n//     damping: 0.15,\n//     decay: 0.001,\n//     duration: 1000,\n//     velocities: [0, 0, 0, 0, 0],\n//     targetValues: [15, 25, 35, 45, 55]\n//   };\n  \n//   const animations = calculateSpringAnimation(matrix, params);\n  "],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","finished","fps","resultsnew","signal","controller","async","sleep","milliseconds","Promise","resolve","setTimeout","Lerp","constructor","this","trigger_start","undefined","trigger_target","trigger_type","type","min","max","duration","render_interval","delay_delta","delay","progress","smoothstep","lerp_chain_start","activelist","results","last_value","reset","id","includes","Float32Array","length","push","update","values","entries","map","val","start_animations","index","LerpChain","buffer","lengths","update_progress","lerp_registry","Callback","callback","threshold","Constant","matrices","numbers","matrix","number","value","constant_registry","condi","lerpChain_registry","v","t","smoothLerp","amount","x","animate","reverse","_lerp_registry$trigge","_lerp_registry$trigge2","_lerp_registry$trigge3","console","log","concat","animateLoop","AbortController","aborted","then","fin","render","postMessage","message","result_indices","filter","stop_loop","start_loop","abort","indices","change_framerate","fps_new","init","lerps","lerpChains","constants","condi_new","springs","Map","forEach","ke","set","eval","arr","name","array","trigger","get_lerp_value","reset_lerp","onmessage","event","data","method","chain_map","callback_map","spring_map","newLength","Spring","elements","spring_tension","spring_whatever","shortest_path","knn","convex_hull","spring"],"sourceRoot":""}