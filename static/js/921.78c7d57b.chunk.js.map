{"version":3,"file":"static/js/921.78c7d57b.chunk.js","mappings":"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","sources":["../webpack/bootstrap","../webpack/runtime/define property getters","../webpack/runtime/hasOwnProperty shorthand","kooljs/worker.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var finished = []\nvar fps = 10.33\nvar signal,controller = null\nvar triggers, triggers_step, status_start, status, startTime, target\nasync function sleep(milliseconds) {\n    return new Promise(resolve => setTimeout(resolve, milliseconds))\n}\n// ----------------------------------------> CLASS DEFINITIONS <--\nclass Lerp {\n    constructor() {\n        this.type = undefined\n        this.type = undefined\n        this.duration = undefined\n        this.render_interval = undefined\n        this.delay_delta = undefined\n        this.delay = undefined\n        this.progress = undefined\n        this.smoothstep = undefined\n        this.lerp_chain_start=undefined\n        this.activelist = []\n        this.results = []\n        this.last_value=[]\n    }\n    reset(id) {\n        if (this.activelist.includes(id) == false) {\n            this.results = new Float32Array(this.results.length + 1)\n            this.activelist.push(id)\n        }\n    }\n    update(id, values) {\n        Object.entries(values).map((val) => {\n            this[val[0]][id] = val[1]\n        })     \n        start_animations(id)\n    }\n    get(index){//this function is for custom callback functions. its used for getting other values via index\n        return this.last_value[index]\n    }\n}\nvar trigger_registry = new Map()\nclass LerpChain{\n    constructor(){\n        this.buffer=undefined\n        this.progress=undefined\n        this.lengths=undefined\n    }\n    update_progress(id){\n        const step=this.progress[id]\n        if(step==this.lengths[id]-1){\n            \n           // this.reset(id)\n            return true\n        }\n        else{\n            \n            this.progress[id]+=1\n            lerp_registry.progress[id]=0\n            return(false)\n        }\n    }\n    reset(id){\n    lerp_registry.reset(id)\n    lerp_registry.progress[id]=0\n    this.progress[id]=0\n    }\n}\nclass Callback {\n    constructor() {\n        // hier einach -1 für keine weights setzen, \n        // oder eine liste erstellen die nur die elemente enthält die eine condi haben\n        this.callback=undefined\n        this.threshold=undefined\n    }\n}\nclass Constant {\n    constructor(matrices,numbers){\n        this.matrix=undefined\n        this.number=undefined\n    }\n   update(type, id, value){\n        constant_registry[type][id]=value\n    }\n    get(type,index){\n        return constant_registry[type][index]\n        }\n}\n// ----------------------------------------> DATABASE <--\nconst lerp_registry = new Lerp()\nconst constant_registry = new Constant()\nconst condi = new Callback()\nconst lerpChain_registry = new LerpChain()\n// ----------------------------------------> ANIMATION <--\nvar v,t\nfunction smoothLerp(min, max, v, amount) {\n    t = smoothstep(v)\n  //  t=(t*amount)/t\n    return (max * t) + (min * (1 - t))\n}\nfunction smoothstep(x) {\n    return x * x * (3 - 2 * x);\n}\n//var triggers,triggers_step\nvar targets\nasync function animate() {\n    lerp_registry.activelist.map((val, index) => {\n        //checking if the element is finished and needs to be deleted\n        if (lerp_registry.progress[val] < lerp_registry.duration[val]) {\n            //waiting for delay\n            if (lerp_registry.delay_delta[val] < lerp_registry.delay[val]) {\n                lerp_registry.delay_delta[val] += 1\n            }\n            else {\n                //increment progress\n                lerp_registry.progress[val] += 1\n                // if (lerp_registry.progress[val] % lerp_registry.render_interval[val] == 0) {\n                    // v = normalized time delta\n                    v = lerp_registry.progress[val] / lerp_registry.duration[val];\n                        triggers=trigger_registry.get(val)\n                        triggers_step=triggers!=undefined?triggers.get(lerpChain_registry.progress[val]):undefined\n                    if ( triggers_step != undefined) {\n                               targets= triggers_step.get(lerp_registry.progress[val])\n                               targets&&targets.map((target)=>{\n                                lerpChain_registry.reset(target)\n                                //trigger_registry.get(val).set(lerpChain_registry.progress[val],triggers_step)\n                                })\n                        }\n                        t= smoothLerp(lerpChain_registry.buffer[lerp_registry.lerp_chain_start[val]+lerpChain_registry.progress[val]],\n                        lerpChain_registry.buffer[lerp_registry.lerp_chain_start[val]+lerpChain_registry.progress[val]+1],\n                        v,\n                        lerp_registry.smoothstep[val]\n                    )\n                    //t += perform callback if there is one\n                    //t = condi.callback.get(val)?.(val, t) ?? undefined; //  Null-Coalescing-Operator -- if callback not undefined then use and process the value t for callback\n                    t=condi.callback.get(val)!=undefined?condi.callback.get(val)(val,t,v):t//?.(val, t) ?? undefined;\n                    //adding the lastvalue for static \n                    lerp_registry.last_value[val] = lerp_registry.results[index] =t // the length of results is equal to the length of activelists\n                // }\n                \n            }\n        } else {\n            if(lerp_registry.lerp_chain_start[val]!=undefined&&lerpChain_registry.update_progress(val)==true){\n                finished.push(val);\n            }\n        }\n    })\n    return finished\n}\nasync function animateLoop() {\n    var startTime \n    controller = new AbortController();\n    signal = controller.signal;\n    while (true) {\n        startTime = performance.now();\n\n        finished = [] // HIER zurücksetzen VOR der Animation\n        if (lerp_registry.activelist.length > 0) {\n            await animate().then(finished=>{\n                if (lerp_registry.results.length > 0) render()\n                if (finished.length > 0) fin()\n            }) \n        }\n        if (signal.aborted) break\n        const elapsed = performance.now() - startTime;\n        const waitTime = Math.max(0, fps - elapsed);\n        await sleep(waitTime);\n\n    }\n}\n// ----------------------------------------> WORKER UTILS <--\nfunction fin() {\n    // postMessage({\n    //     message: \"finish\",\n    //     results: lerp_registry.results,\n    //     result_indices: lerp_registry.activelist\n    // });\n    lerp_registry.activelist = lerp_registry.activelist.filter((active) => !finished.includes(active));\n    if (lerp_registry.activelist[\"length\"] == 0) {\n        stop_loop()\n        lerp_registry.results=[]\n    }else{\n        lerp_registry.results = new Float32Array(lerp_registry.activelist.length);\n    }\n    finished = []\n}\nfunction start_loop() {\n    animateLoop()\n}\nfunction stop_loop() {\n    if (controller !== null) {\n        controller.abort()\n        controller = null\n    }\n    lerp_registry.activelist=[]\n    lerp_registry.results=[]\n    // lerp_registry.last_value=[]\n}\nfunction start_animations(indices){\n    indices.map((id)=>{\n        lerpChain_registry.reset(id)\n    if (controller == null) {\n        start_loop()\n    } \n        \n    })\n}\nfunction change_framerate(fps_new) {\n    fps = fps_new\n}\nfunction init(lerps, lerpChains, triggers, constants, condi_new, springs) {\n    trigger_registry=(triggers)\n    condi.callback=new Map()\n    condi_new.get(\"callback\").forEach((val,ke)=>{\n          condi.callback.set(ke,eval(val))\n    })\n    lerpChains.forEach((arr,name)=>{\n        if(name!=\"buffer\"){\n            lerpChain_registry[name]=arr\n        }\n        else{\n            lerpChain_registry[name]=new Float32Array(arr)\n          //  console.log(lerpChain_registry[name])\n        }\n    })\n    condi.threshold= new Float32Array(condi_new.threshold)\n    lerps.forEach((array, name) => {\n            lerp_registry[name] = new Float32Array(array)\n    })\n    if(constants.get(\"matrix\")!=undefined){\n    constants.get(\"matrix\").forEach((val)=>{\n        constant_registry.matrix.push(new Float32Array(val))\n    })\n}\n    if(constants.get(\"number\")!=undefined){\n            constant_registry.number=(new Float32Array(constants.get(\"number\")))\n    }\n    lerp_registry.last_value=new Float32Array(lerp_registry.progress)\n    lerp_registry.activelist = []\n}\n// ----------------------------------------> EVENTS <--\nasync function render() {\n    postMessage({ message: \"render\", results: lerp_registry.results, result_indices: lerp_registry.activelist })\n}\nonmessage = (event) => {\n    // eslint-disable-next-line default-case\n    switch (event.data.method) {\n        case 'init':\n            init(event.data.data, event.data.chain_map, event.data.trigger_map, event.data.constants, event.data.callback_map,event.data.spring_map,);\n            break;\n        case 'update_lerp':\n            lerp_registry.update(event.data.id, event.data.values);\n            break;\n        case \"update\":\n                    if(event.data.type==2){\n                        event.data.data.map((x)=>{\n                            lerpChain_registry.lengths[x.id]=x.values.length-1\n                            x.values.map((val,i)=>{\n                                lerpChain_registry.buffer[lerp_registry.lerp_chain_start[x.id]+i]=val\n                            })\n                            lerpChain_registry.reset(x.id)\n                           // lerpChain_registry.reset(event.data.id)\n                        })\n                    // lerpChain_registry.buffer=new Float32Array(event.data.buffer)\n                    }\n            break\n        case 'update_constant':\n            constant_registry.update(event.data.type, event.data.id,event.data.value);\n            break;\n        case 'start_loop':\n            change_framerate(event.data.fps)\n            start_loop();\n            break;\n        case 'stop':\n            stop_loop();\n            break;\n        case 'change_framerate':\n            change_framerate(event.data.fps_new);\n            break;\n        case 'start':\n            start_animations(event.data.indices);\n            break;\n    }\n};\nfunction get_lerp_value(id){return lerp_registry.get(id)}\nfunction reset_lerp(id){return lerp_registry.reset_lerp(id)}\nexport {get_lerp_value,reset_lerp,set,change_framerate}\n\n// ----------------------------------------> REQUIRES IMPLEMENTATION <--\nfunction set(id){\n    //activelist,results,lastvalue,min/max\n}\nclass Spring{\n    constructor(elements,duration,spring_tension,spring_whatever,){\n            this.elements=elements\n            this.duration=duration\n            this.spring_tension=spring_tension\n    \n    }\n    }\n//dijkstra algo für matrix\nfunction shortest_path(){\n\n}\n// k nearest neigbor for matrix (not sure if also for lerp)\nfunction knn(){\n\n}\n//matrix and callback for lerp\nfunction convex_hull(){\n\n}\nfunction spring(){\n\n}\n// function triggers() {\n//     postMessage({ message: \"trigger\", results: lerp_registry.results, result_indices: lerp_registry.activelist })\n// }\n\n\n//v = Math.floor(registry.progress[val] / registry.duration[val]);\n\n\n\n// function calculateSpringAnimation(matrix, params) {\n//     const { mass, tension, friction, bounce, damping, decay, duration, velocities } = params;\n  \n//     return matrix.map((value, index) => {\n//       const initialValue = value;\n//       const targetValue = params.targetValues ? params.targetValues[index] : initialValue;\n      \n//       const k = 2 * Math.PI * Math.sqrt(tension / mass);\n//       const zeta = damping / (2 * mass);\n//       const omega = k * Math.sqrt(1 - zeta * zeta);\n  \n//       return (t) => {\n//         const x = targetValue - initialValue;\n//         const theta = omega * t;\n  \n//         let y;\n//         if (zeta < 1) {\n//           // Unter- oder kritisch gedämpft\n//           y = x * Math.exp(-zeta * theta) * (Math.cos(theta) + (zeta / omega) * Math.sin(theta));\n//         } else {\n//           // Überdämpft\n//           y = x * Math.exp(-omega * t);\n//         }\n  \n//         // Bounce-Effekt hinzufügen\n//         const bounceFactor = Math.pow(0.9, t / duration);\n//         y *= bounceFactor;\n  \n//         // Auslaufwert berücksichtigen\n//         return targetValue + (y - targetValue) * Math.exp(-decay * t);\n//       };\n//     });\n//   }\n  \n//   // Beispielaufruf:\n//   const matrix = [10, 20, 30, 40, 50];\n//   const params = {\n//     mass: 0.5,\n//     tension: 100,\n//     friction: 0.05,\n//     bounce: 0.9,\n//     damping: 0.15,\n//     decay: 0.001,\n//     duration: 1000,\n//     velocities: [0, 0, 0, 0, 0],\n//     targetValues: [15, 25, 35, 45, 55]\n//   };\n  \n//   const animations = calculateSpringAnimation(matrix, params);\n  "],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","finished","fps","signal","controller","triggers","triggers_step","status_start","status","startTime","target","async","sleep","milliseconds","Promise","resolve","setTimeout","Lerp","constructor","this","type","undefined","duration","render_interval","delay_delta","delay","progress","smoothstep","lerp_chain_start","activelist","results","last_value","reset","id","includes","Float32Array","length","push","update","values","entries","map","val","start_animations","index","trigger_registry","Map","LerpChain","buffer","lengths","update_progress","lerp_registry","Callback","callback","threshold","Constant","matrices","numbers","matrix","number","value","constant_registry","condi","lerpChain_registry","v","t","targets","smoothLerp","min","max","amount","x","animate","animateLoop","AbortController","performance","now","then","render","fin","aborted","elapsed","waitTime","Math","filter","active","stop_loop","start_loop","abort","indices","change_framerate","fps_new","init","lerps","lerpChains","constants","condi_new","springs","forEach","ke","set","eval","arr","name","array","postMessage","message","result_indices","get_lerp_value","reset_lerp","onmessage","event","data","method","chain_map","trigger_map","callback_map","spring_map","i","Spring","elements","spring_tension","spring_whatever","shortest_path","knn","convex_hull","spring"],"sourceRoot":""}