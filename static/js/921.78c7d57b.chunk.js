(()=>{"use strict";var __webpack_require__={d:(r,e)=>{for(var t in e)__webpack_require__.o(e,t)&&!__webpack_require__.o(r,t)&&Object.defineProperty(r,t,{enumerable:!0,get:e[t]})},o:(r,e)=>Object.prototype.hasOwnProperty.call(r,e)},__webpack_exports__={},finished=[],fps=10.33,signal,controller=null,triggers,triggers_step,status_start,status,startTime,target;async function sleep(r){return new Promise((e=>setTimeout(e,r)))}class Lerp{constructor(){this.type=void 0,this.type=void 0,this.duration=void 0,this.render_interval=void 0,this.delay_delta=void 0,this.delay=void 0,this.progress=void 0,this.smoothstep=void 0,this.lerp_chain_start=void 0,this.activelist=[],this.results=[],this.last_value=[]}reset(r){0==this.activelist.includes(r)&&(this.results=new Float32Array(this.results.length+1),this.activelist.push(r))}update(r,e){Object.entries(e).map((e=>{this[e[0]][r]=e[1]})),start_animations(r)}get(r){return this.last_value[r]}}var trigger_registry=new Map;class LerpChain{constructor(){this.buffer=void 0,this.progress=void 0,this.lengths=void 0}update_progress(r){return this.progress[r]==this.lengths[r]-1||(this.progress[r]+=1,lerp_registry.progress[r]=0,!1)}reset(r){lerp_registry.reset(r),lerp_registry.progress[r]=0,this.progress[r]=0}}class Callback{constructor(){this.callback=void 0,this.threshold=void 0}}class Constant{constructor(r,e){this.matrix=void 0,this.number=void 0}update(r,e,t){constant_registry[r][e]=t}get(r,e){return constant_registry[r][e]}}const lerp_registry=new Lerp,constant_registry=new Constant,condi=new Callback,lerpChain_registry=new LerpChain;var v,t,targets;function smoothLerp(r,e,s,a){return e*(t=smoothstep(s))+r*(1-t)}function smoothstep(r){return r*r*(3-2*r)}async function animate(){return lerp_registry.activelist.map(((r,e)=>{lerp_registry.progress[r]<lerp_registry.duration[r]?lerp_registry.delay_delta[r]<lerp_registry.delay[r]?lerp_registry.delay_delta[r]+=1:(lerp_registry.progress[r]+=1,v=lerp_registry.progress[r]/lerp_registry.duration[r],triggers=trigger_registry.get(r),void 0!=(triggers_step=void 0!=triggers?triggers.get(lerpChain_registry.progress[r]):void 0)&&(targets=triggers_step.get(lerp_registry.progress[r]))&&targets.map((r=>{lerpChain_registry.reset(r)})),t=smoothLerp(lerpChain_registry.buffer[lerp_registry.lerp_chain_start[r]+lerpChain_registry.progress[r]],lerpChain_registry.buffer[lerp_registry.lerp_chain_start[r]+lerpChain_registry.progress[r]+1],v,lerp_registry.smoothstep[r]),t=void 0!=condi.callback.get(r)?condi.callback.get(r)(r,t,v):t,lerp_registry.last_value[r]=lerp_registry.results[e]=t):void 0!=lerp_registry.lerp_chain_start[r]&&1==lerpChain_registry.update_progress(r)&&finished.push(r)})),finished}async function animateLoop(){var r;for(controller=new AbortController,signal=controller.signal;r=performance.now(),finished=[],lerp_registry.activelist.length>0&&await animate().then((r=>{lerp_registry.results.length>0&&render(),r.length>0&&fin()})),!signal.aborted;){const e=performance.now()-r,t=Math.max(0,fps-e);await sleep(t)}}function fin(){lerp_registry.activelist=lerp_registry.activelist.filter((r=>!finished.includes(r))),0==lerp_registry.activelist.length?(stop_loop(),lerp_registry.results=[]):lerp_registry.results=new Float32Array(lerp_registry.activelist.length),finished=[]}function start_loop(){animateLoop()}function stop_loop(){null!==controller&&(controller.abort(),controller=null),lerp_registry.activelist=[],lerp_registry.results=[]}function start_animations(r){r.map((r=>{lerpChain_registry.reset(r),null==controller&&start_loop()}))}function change_framerate(r){fps=r}function init(lerps,lerpChains,triggers,constants,condi_new,springs){trigger_registry=triggers,condi.callback=new Map,condi_new.get("callback").forEach(((val,ke)=>{condi.callback.set(ke,eval(val))})),lerpChains.forEach(((r,e)=>{lerpChain_registry[e]="buffer"!=e?r:new Float32Array(r)})),condi.threshold=new Float32Array(condi_new.threshold),lerps.forEach(((r,e)=>{lerp_registry[e]=new Float32Array(r)})),void 0!=constants.get("matrix")&&constants.get("matrix").forEach((r=>{constant_registry.matrix.push(new Float32Array(r))})),void 0!=constants.get("number")&&(constant_registry.number=new Float32Array(constants.get("number"))),lerp_registry.last_value=new Float32Array(lerp_registry.progress),lerp_registry.activelist=[]}async function render(){postMessage({message:"render",results:lerp_registry.results,result_indices:lerp_registry.activelist})}function get_lerp_value(r){return lerp_registry.get(r)}function reset_lerp(r){return lerp_registry.reset_lerp(r)}function set(r){}onmessage=r=>{switch(r.data.method){case"init":init(r.data.data,r.data.chain_map,r.data.trigger_map,r.data.constants,r.data.callback_map,r.data.spring_map);break;case"update_lerp":lerp_registry.update(r.data.id,r.data.values);break;case"update":2==r.data.type&&r.data.data.map((r=>{lerpChain_registry.lengths[r.id]=r.values.length-1,r.values.map(((e,t)=>{lerpChain_registry.buffer[lerp_registry.lerp_chain_start[r.id]+t]=e})),lerpChain_registry.reset(r.id)}));break;case"update_constant":constant_registry.update(r.data.type,r.data.id,r.data.value);break;case"start_loop":change_framerate(r.data.fps),start_loop();break;case"stop":stop_loop();break;case"change_framerate":change_framerate(r.data.fps_new);break;case"start":start_animations(r.data.indices)}};class Spring{constructor(r,e,t,s){this.elements=r,this.duration=e,this.spring_tension=t}}function shortest_path(){}function knn(){}function convex_hull(){}function spring(){}})();
//# sourceMappingURL=921.78c7d57b.chunk.js.map