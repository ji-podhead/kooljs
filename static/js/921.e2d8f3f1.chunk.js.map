{"version":3,"file":"static/js/921.e2d8f3f1.chunk.js","mappings":"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","sources":["../webpack/bootstrap","../webpack/runtime/define property getters","../webpack/runtime/hasOwnProperty shorthand","kooljs/worker.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// Copyright (c) 2025 Ji-Podhead and Project Contributors\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, subject to the following conditions:\n\n// 1. All commercial uses of the Software must:  \n//    a) Include visible attribution to all contributors (listed in CONTRIBUTORS.md).  \n//    b) Provide a direct link to the original project repository (https://github.com/ji-podhead/kooljs).  \n\n// 2. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  \nvar finished = []\nvar fps = 10.33\nvar signal,controller = null\nvar triggers_step\nasync function sleep(milliseconds) {\n    return new Promise(resolve => setTimeout(resolve, milliseconds))\n}\n// ----------------------------------------> CLASS DEFINITIONS <--\nclass Lerp {\n    constructor() {\n        this.type = undefined\n        this.delta_t = undefined\n        this.duration = undefined\n        this.render_interval = undefined\n        this.delay_delta = undefined\n        this.delay = undefined\n        this.progress = undefined\n        this.smoothstep = undefined\n        this.lerp_chain_start=undefined\n        this.loop=undefined\n        this.activelist = []\n        this.results = new Map()\n    }\n    reset(id) {\n        if (this.activelist.includes(id) == false) {\n            this.activelist.push(id)\n        }\n    }\n    get(index){//this function is for custom callback functions. its used for getting other values via index\n        return this.results.get(index)\n    }\n}\nvar trigger_registry = new Map()\nclass LerpChain{\n    constructor(){\n        this.buffer=undefined\n        this.matrixChains=undefined\n        this.progress=undefined\n        this.lengths=undefined\n    }\n    update_progress(id){\n        const step=this.progress[id]\n        if(step==this.lengths[id]-1){\n            return true\n        }\n        else{\n            \n            this.progress[id]+=1\n            lerp_registry.progress[id]=0\n            return(false)\n        }\n    }\n    reset(id){\n    lerp_registry.reset(id)\n    lerp_registry.progress[id]=0\n    this.progress[id]=0\n    }\n    soft_reset(id){\n        if(lerp_registry.progress[id]==lerp_registry.duration[id]){\n            lerp_registry.reset(id)\n            lerp_registry.progress[id]=0\n        }\n        if(lerpChain_registry.progress[id]==lerpChain_registry.lengths[id]-1){\n            lerpChain_registry.reset(id)\n        }\n        else if(lerp_registry.activelist.includes(id)==false){\n            lerp_registry.activelist.push(id)\n        }\n    }\n}\nclass Callback {\n    constructor() {\n        // hier einach -1 für keine weights setzen, \n        // oder eine liste erstellen die nur die elemente enthält die eine condi haben\n        this.callback=new Map()\n        this.condition=new Map()\n    }\n}\nclass Constant {\n    constructor(matrices,numbers){\n        this.matrix=undefined\n        this.number=undefined\n    }\n   update(type, id, value){\n        constant_registry[type][id]=value\n    }\n    get(type,index){\n        return constant_registry[type][index]\n        }\n}\n// ----------------------------------------> DATABASE <--\nconst lerp_registry = new Lerp()\nconst constant_registry = new Constant()\nconst callback_registry = new Callback()\nconst lerpChain_registry = new LerpChain()\n\n// ----------------------------------------> ANIMATION <--\nvar t\nfunction smoothLerp(min, max, v, amount) {\n    t = smoothstep(v)\n  //  t=(t*amount)/t\n    return (max * t) + (min * (1 - t))\n}\nfunction smoothstep(x) {\n    return x * x * (3 - 2 * x);\n}\n//var triggers,triggers_step\nvar targets\nasync function animate() {\n    finished=[]\n    lerp_registry.activelist.map((val, index) => {\n        //checking if the element is finished and needs to be deleted\n        if (lerp_registry.progress[val] < lerp_registry.duration[val]) {\n            //waiting for delay\n            if (lerp_registry.delay_delta[val] < lerp_registry.delay[val]) {\n                lerp_registry.delay_delta[val] += 1\n            }\n            else {\n                //increment progress\n                lerp_registry.progress[val] += 1\n                // if (lerp_registry.progress[val] % lerp_registry.render_interval[val] == 0) {\n                    lerp_registry.delta_t[val] = lerp_registry.progress[val] / lerp_registry.duration[val];\n\n                    switch(lerp_registry.type[val]){\n                        case(2):\n                        lerp_registry.results.set(val, smoothLerp(\n                                lerpChain_registry.buffer[lerp_registry.lerp_chain_start[val]+lerpChain_registry.progress[val]],\n                                lerpChain_registry.buffer[lerp_registry.lerp_chain_start[val]+lerpChain_registry.progress[val]+1],\n                                lerp_registry.delta_t[val] ,\n                                lerp_registry.smoothstep[val]\n                            ))\n                            break\n                        case(3):\n                            for (let i=0;i< lerpChain_registry.matrixChains.get(val).get(lerpChain_registry.progress[val]).length;i++)\n                            {\n                                lerp_registry.results.get(val)[i]=  smoothLerp(\n                                    lerpChain_registry.matrixChains.get(val).get(lerpChain_registry.progress[val])[i],\n                                    lerpChain_registry.matrixChains.get(val).get(lerpChain_registry.progress[val]+1)[i],\n                                    lerp_registry.delta_t[val] ,\n                                    lerp_registry.smoothstep[val]\n                                )\n                            }\n                            break;\n                        default:\n                            return console.error(\"wrong type\"+String(val));\n                    }\n                    const args={id:val,value:lerp_registry.results.get(val),time:lerp_registry.progress[val] ,step:lerpChain_registry.progress[val]} //time war vorther lerp_registry.delta_t[val]\n                   if(callback_registry.condition.get(val)!=undefined\n                   &&callback_registry.condition.get(val)(args)==true) {\n                     callback_registry.callback.get(val)(args)\n                   }\n                   triggers_step=trigger_registry.get(val)!=undefined?trigger_registry.get(val).get(lerpChain_registry.progress[val]):undefined\n                   if ( triggers_step != undefined) {\n                              targets= triggers_step.get(lerp_registry.progress[val])\n                              targets&&targets.map((target)=>{\n\n                               lerpChain_registry.soft_reset(target)\n                               })\n                   }\n            }\n        } else {\n            if(lerp_registry.lerp_chain_start[val]!=undefined&&lerpChain_registry.update_progress(val)==true){\n                finished.push(val);\n            }\n        }\n    })\n    return finished\n}\n//t = callback_registry.callback.get(val)?.(val, t) ?? undefined; //  Null-Coalescing-Operator -- if callback not undefined then use and process the value t for callback\n\nasync function animateLoop() {\n    var startTime \n    controller = new AbortController();\n    signal = controller.signal;\n    while (true) {\n        if (signal.aborted || controller==null) break\n        startTime = performance.now();\n        finished = [] // HIER zurücksetzen VOR der Animation\n        if (lerp_registry.activelist.length > 0) {\n            await animate().then(finished=>{\n                 render()\n                if (finished.length > 0) fin(finished)\n            }) \n        }\n        \n        const elapsed = performance.now() - startTime;\n        const waitTime = Math.max(0, fps - elapsed);\n        await sleep(waitTime);\n\n    }\n}\n// ----------------------------------------> WORKER UTILS <--\nfunction fin(finished) {\n    // postMessage({\n    //     message: \"finish\",\n    //     results: lerp_registry.results,\n    //     result_indices: lerp_registry.activelist\n    // });\n    lerp_registry.activelist = lerp_registry.activelist.filter((active) => !finished.includes(active));\n    if (lerp_registry.activelist[\"length\"] == 0) {\n        stop_loop()\n    }\n}\nfunction start_loop() {\n    if(controller==null){\n        animateLoop()\n    }\n}\nfunction stop_loop() {\n    if (controller !== null) {\n        controller.abort()\n        controller = null\n    }\n    //lerp_registry.activelist=[]\n    // lerp_registry.last_value=[]\n}\nfunction start_animations(indices){\n    indices.map((id)=>{\n        lerpChain_registry.soft_reset(id)\n        start_loop()\n    })\n}\nfunction stop_animations(indices){\n    if(indices==\"all\"){\n        indices=lerp_registry.activelist\n    }\n    indices.map((id)=>{\n        if(lerp_registry.activelist.includes(id)){\n        //lerpChain_registry.reset(id)\n        lerp_registry.activelist=lerp_registry.activelist.filter((x)=>x!=id)\n        }\n    if (lerp_registry.activelist.length == 0) {\n        stop_loop()\n    } \n  })\n}\n\nasync function reset_animations(indices){\n    if(indices==\"all\"){stop_loop();indices=lerp_registry.activelist}\n    //stop_animations(indices)\n    const stopped=[]    \n    indices.map((x)=>{\n        lerpChain_registry.reset(x);\n        lerp_registry.reset(x)\n        if(lerp_registry.activelist.includes(x)==false || controller==null){\n            stopped.push(x)\n            switch(lerp_registry.type[x]){\n            case(2):\n            lerp_registry.results.set(x,lerpChain_registry.buffer[lerp_registry.lerp_chain_start[x]])\n            break\n            case(3):\n            lerp_registry.results.set(x,lerpChain_registry.matrixChains.get(x).get(0))\n            break\n            default:break;\n            \n        }\n    }\n    })\n    if(stopped.length>0)    postMessage({ message: \"render\", results: lerp_registry.results, result_indices: indices })\n}\nfunction change_framerate(fps_new) {\n    fps = fps_new\n}\nfunction init(lerps, lerpChains, matrixChains, triggers, constants, condi_new, springs) {\n    trigger_registry=(triggers)\n    condi_new.forEach((val,key)=>{\n          callback_registry.callback.set(key,eval(val.callback))\n          callback_registry.condition.set(key,eval(val.condition))\n    })\n    lerpChains.forEach((arr,name)=>{\n            lerpChain_registry[name]=new Float32Array(arr)\n          //  console.log(lerpChain_registry[name])\n    })\n    lerpChain_registry.matrixChains=matrixChains\n    lerps.forEach((array, name) => {\n            if([\"loop\"].includes(name)==false ){\n            lerp_registry[name] = new Float32Array(array)\n            }\n            else{lerp_registry[name] = new Uint8Array(array)}\n    })\n    if(constants.get(\"matrix\")!=undefined){\n    constants.get(\"matrix\").forEach((val)=>{\n        constant_registry.matrix.push(new Float32Array(val))\n    })\n}\n    if(constants.get(\"number\")!=undefined){\n            constant_registry.number=(new Float32Array(constants.get(\"number\")))\n    }\n    lerp_registry.type.map((t,i)=>{\n        if(t==2){\n            lerp_registry.results.set(i,-1)\n        }\n        else{\n            lerp_registry.results.set(i,new Float32Array(lerpChain_registry.matrixChains.get(i).get(0)))\n        }\n    })\n    lerp_registry.delta_t=new Float32Array(lerp_registry.duration.length)\n}\nfunction addTrigger(id,target,step,time){\n    var trigger = []\n    if(trigger_registry.get(id).get(step)==undefined){\n        trigger_registry.get(id).set(step, new Map())\n        trigger_registry.get(id).get(step).set(time,new Uint8Array([target]))\n    }\n    else if(trigger_registry.get(id).get(step).get(time)==undefined){\n        trigger_registry.get(id).get(step).set(time,new Uint8Array([target]))\n    }\n    else{\n    trigger=trigger_registry.get(id).get(step).get(time)\n    console.log(trigger)\n    if(trigger.includes(target)==false){\n        const newtriggers= new Uint8Array(new Array(trigger).push(target))\n        console.log(newtriggers)\n        trigger_registry.get(id).get(step).set(time,newtriggers)\n    }\n}\n}\nfunction removeTrigger(id,target,step,time){\n    var trigger=trigger_registry.get(id).get(step)\n    \n    if(trigger!=undefined)\n        {\n            trigger=trigger.get(time)!=undefined?trigger.get(time):trigger\n        }\n        else{\n            return(console.error(\"the trigger registr has now element for the step\"))\n        }\n    \n    console.log(trigger)\n    if(trigger!= undefined&&trigger.includes(target)==false&&trigger_registry.get(id).get(step).get(time).length>1){\n        const newtriggers= new Uint8Array(new Array(trigger).splice(trigger.find(target),1))\n        console.log(newtriggers)\n        trigger_registry.get(id).get(step).set(time,newtriggers)\n    }\n    else if(trigger_registry.get(id).get(step).size>1) {\n        trigger_registry.get(id).get(step).set(time,undefined)\n    }\n    else{\n        trigger_registry.get(id).set(step,undefined)\n    }\n}\nfunction update(type,values){\n        values.map((x)=>{\n            if(lerpChain_registry.lengths[x.id]!=x.values.length-1){\n                console.log(trigger_registry.get(x.id))\n                if(lerp_registry.loop[x.id]==1){\n                removeTrigger(x.id,x.id,lerpChain_registry.lengths[x.id]-1,lerp_registry.duration[x.id])\n                addTrigger(x.id,x.id,x.values.length-2,lerp_registry.duration[x.id])\n                \n                //trigger_registry.get(x.id).set(lerpChain_registry.lengths[x.id]-1,undefined)\n            }\n            lerpChain_registry.lengths[x.id]=x.values.length-1\n        }\n            if(type==2){\n            x.values.map((val,i)=>{\n                lerpChain_registry.buffer[lerp_registry.lerp_chain_start[x.id]+i]=val\n            })\n        }\n        else if(type==3){\n            x.values.map((val,i)=>{\n                lerpChain_registry.matrixChains.get(x.id).set(i,val)\n            })\n        }\n        lerpChain_registry.reset(x.id)\n    })\n}\n\n// ----------------------------------------> EVENTS <--\nasync function render() {\n    postMessage({ message: \"render\", results: lerp_registry.results, result_indices: lerp_registry.activelist })\n}\nonmessage = (event) => {\n    // eslint-disable-next-line default-case\n    switch (event.data.method) {\n        case 'init':\n            init(event.data.data, event.data.chain_map, event.data.matrix_chain_map, event.data.trigger_map, event.data.constants, event.data.callback_map,event.data.spring_map,);\n            break;\n        case \"update\":\n            update(event.data.type,event.data.data)\n            break\n        case 'update_constant':\n            constant_registry.update(event.data.type, event.data.id,event.data.value);\n            break;\n        case 'start':\n            start_loop();\n            break;\n        case 'stop':\n            stop_loop();\n            break;\n        case 'change_framerate':\n            change_framerate(event.data.fps_new);\n            break;\n        case 'start_animations':\n            start_animations(event.data.indices);\n            break;\n        case 'stop_animations':\n            stop_animations(event.data.indices);\n            break;\n        case 'reset_animations':\n            reset_animations(event.data.indices);\n            break;\n        case 'addTrigger':\n            addTrigger(event.data.id,event.data.target,event.data.step,event.data.time);\n            break;\n        case 'removeTrigger':\n            removeTrigger(event.data.id,event.data.target,event.data.step,event.data.time);\n            break;\n    }\n};\nfunction setLerp(index,step,value){\n    //console.log(lerpChain_registry.buffer[lerp_registry.lerp_chain_start[index]+step])\n    lerpChain_registry.buffer[lerp_registry.lerp_chain_start[index]+step]=value\n}\nfunction setMatrix(index,step,value){\n   // console.log(lerpChain_registry.matrixChains.get(index).get(step))\n    value.map((x,i) => {\n        lerpChain_registry.matrixChains.get(index).get(step)[i]=x\n    })\n   // lerpChain_registry.matrixChains.get(index).get(step)\n}\nfunction get_time(id){return lerp_registry.delay_delta(id)}\nfunction current_step(id){return lerpChain_registry.progress(id)}\nfunction get_lerp_value(id){return lerp_registry.results.get(id)}\nfunction reset_lerp(id){lerp_registry.reset_lerp(id)}\nfunction set_duration(id,val){lerp_registry.duration[id]=val}\nfunction set_sequence_length(id,val){lerpChain_registry.lengths[id]=val}\nexport {\n    addTrigger,removeTrigger,\n    get_time,current_step,\n    start_animations,stop_animations,\n    setLerp,setMatrix,\n    get_lerp_value,\n    reset_lerp,\n    set_duration,\n    set_sequence_length,\n    change_framerate\n}\n\n// ----------------------------------------> REQUIRES IMPLEMENTATION <--\n\nclass Spring{\n    constructor(elements,duration,spring_tension,spring_whatever,){\n            this.elements=elements\n            this.duration=duration\n            this.spring_tension=spring_tension\n    \n    }\n    }\n//dijkstra algo für matrix\nfunction shortest_path(){\n\n}\n// k nearest neigbor for matrix (not sure if also for lerp)\nfunction knn(){\n\n}\n//matrix and callback for lerp\nfunction convex_hull(){\n\n}\nfunction spring(){\n\n}\n// function triggers() {\n//     postMessage({ message: \"trigger\", results: lerp_registry.results, result_indices: lerp_registry.activelist })\n// }\n\n\n//v = Math.floor(registry.progress[val] / registry.duration[val]);\n\n\n\n// function calculateSpringAnimation(matrix, params) {\n//     const { mass, tension, friction, bounce, damping, decay, duration, velocities } = params;\n  \n//     return matrix.map((value, index) => {\n//       const initialValue = value;\n//       const targetValue = params.targetValues ? params.targetValues[index] : initialValue;\n      \n//       const k = 2 * Math.PI * Math.sqrt(tension / mass);\n//       const zeta = damping / (2 * mass);\n//       const omega = k * Math.sqrt(1 - zeta * zeta);\n  \n//       return (t) => {\n//         const x = targetValue - initialValue;\n//         const theta = omega * t;\n  \n//         let y;\n//         if (zeta < 1) {\n//           // Unter- oder kritisch gedämpft\n//           y = x * Math.exp(-zeta * theta) * (Math.cos(theta) + (zeta / omega) * Math.sin(theta));\n//         } else {\n//           // Überdämpft\n//           y = x * Math.exp(-omega * t);\n//         }\n  \n//         // Bounce-Effekt hinzufügen\n//         const bounceFactor = Math.pow(0.9, t / duration);\n//         y *= bounceFactor;\n  \n//         // Auslaufwert berücksichtigen\n//         return targetValue + (y - targetValue) * Math.exp(-decay * t);\n//       };\n//     });\n//   }\n  \n//   // Beispielaufruf:\n//   const matrix = [10, 20, 30, 40, 50];\n//   const params = {\n//     mass: 0.5,\n//     tension: 100,\n//     friction: 0.05,\n//     bounce: 0.9,\n//     damping: 0.15,\n//     decay: 0.001,\n//     duration: 1000,\n//     velocities: [0, 0, 0, 0, 0],\n//     targetValues: [15, 25, 35, 45, 55]\n//   };\n  \n//   const animations = calculateSpringAnimation(matrix, params);\n  "],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","finished","fps","signal","controller","triggers_step","async","sleep","milliseconds","Promise","resolve","setTimeout","Lerp","constructor","this","type","undefined","delta_t","duration","render_interval","delay_delta","delay","progress","smoothstep","lerp_chain_start","loop","activelist","results","Map","reset","id","includes","push","index","trigger_registry","LerpChain","buffer","matrixChains","lengths","update_progress","lerp_registry","soft_reset","lerpChain_registry","Callback","callback","condition","Constant","matrices","numbers","matrix","number","update","value","constant_registry","callback_registry","t","targets","smoothLerp","min","max","v","amount","x","animate","map","val","set","i","length","console","error","String","args","time","step","target","animateLoop","startTime","AbortController","aborted","performance","now","then","render","fin","elapsed","waitTime","Math","filter","active","stop_loop","start_loop","abort","start_animations","indices","stop_animations","reset_animations","stopped","postMessage","message","result_indices","change_framerate","fps_new","init","lerps","lerpChains","triggers","constants","condi_new","springs","forEach","eval","arr","name","Float32Array","array","Uint8Array","addTrigger","trigger","log","newtriggers","Array","removeTrigger","splice","find","size","values","setLerp","setMatrix","get_time","current_step","get_lerp_value","reset_lerp","set_duration","set_sequence_length","onmessage","event","data","method","chain_map","matrix_chain_map","trigger_map","callback_map","spring_map","Spring","elements","spring_tension","spring_whatever","shortest_path","knn","convex_hull","spring"],"sourceRoot":""}