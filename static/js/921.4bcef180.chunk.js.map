{"version":3,"file":"static/js/921.4bcef180.chunk.js","mappings":"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","sources":["../webpack/bootstrap","../webpack/runtime/define property getters","../webpack/runtime/hasOwnProperty shorthand","kooljs/worker.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// Copyright (c) 2025 Ji-Podhead and Project Contributors\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, subject to the following conditions:\n\n// 1. All commercial uses of the Software must:  \n//    a) Include visible attribution to all contributors (listed in CONTRIBUTORS.md).  \n//    b) Provide a direct link to the original project repository (https://github.com/ji-podhead/kooljs).  \n\n// 2. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  \nvar finished = []\nvar fps = 10.33\nvar signal,loop_resolver = null\nvar triggers_step\nvar status=true\nasync function sleep(milliseconds) {\n    return new Promise(resolve => setTimeout(resolve, milliseconds))\n}\n// ----------------------------------------> CLASS DEFINITIONS <--\nclass Lerp {\n    constructor() {\n        this.type = undefined\n        this.delta_t = undefined\n        this.duration = undefined\n        this.render_interval = undefined\n        this.delay_delta = undefined\n        this.delay = undefined\n        this.progress = undefined\n        this.smoothstep = undefined\n        this.lerp_chain_start=undefined\n        this.loop=undefined\n        this.activelist = []\n        this.results = new Map()\n    }\n    activate(id) {\n        if (this.activelist.includes(id) == false) {\n            this.activelist.push(id)\n            return true\n        }\n        return false\n    }\n    get(index){//this function is for custom callback functions. its used for getting other values via index\n        return this.results.get(index)\n    }\n}\nvar final_step,final_sub_step\nclass LerpChain{\n    constructor(){\n        this.buffer=undefined\n        this.matrixChains=undefined\n        this.progress=undefined\n        this.lengths=undefined\n    }\n    update_progress(id){\n        if(this.progress[id]==this.lengths[id]-1){\n            return true\n        }\n        else{\n            this.reset_and_update(id)\n            return(false)\n        }\n    }\n    reset_and_update(id){\n        lerp_registry.delay_delta[id]=0\n        lerp_registry.progress[id]=0\n        this.progress[id]+=1\n    }\n    reset(id){\n        if(lerp_registry.type[id]==2){\n            lerp_registry.results.set(id,lerpChain_registry.buffer[lerp_registry.lerp_chain_start[id]])\n        }\n        else{\n            lerp_registry.results.set(id,lerpChain_registry.matrixChains.get(id).get(0))\n        }\n        lerp_registry.delay_delta[id]=0\n        lerp_registry.progress[id]=0   \n        this.progress[id]=0\n    }\n    soft_reset(id){\n        final_step=this.progress[id]==this.lengths[id]-1\n        final_sub_step=lerp_registry.progress[id]>=lerp_registry.duration[id]\n        lerp_registry.activate(id)\n        if(final_step && final_sub_step){\n            this.reset(id)\n        }\n        else if(final_sub_step){\n            this.reset_and_update(id)\n        }\n    }\n}\nclass Callback {\n    constructor() {\n        this.callback=new Map()\n        this.condition=new Map()\n    }\n}\nclass Constant {\n    constructor(matrices,numbers){\n        this.matrix=new Map()\n        this.number=undefined\n    }\n   update(type, id, value){\n        constant_registry[type].set(id,value)\n    }\n    get(type,index,row){\n        if(row!=undefined){\n            this.get_row(index,row)\n        }\n        else return constant_registry[type].get(index)\n    }\n    get_row(index,row){\n        return constant_registry[\"matrix\"].get(index).get(row)\n    }\n    get_number(index){\n        return constant_registry[\"number\"].get(index)\n    }\n}\n// ----------------------------------------> DATABASE <--\nconst lerp_registry = new Lerp()\nconst constant_registry = new Constant()\nconst callback_registry = new Callback()\nconst lerpChain_registry = new LerpChain()\nconst lambda_registry = new Callback()\nconst trigger_registry = new Map()\n// ----------------------------------------> ANIMATION <--\nvar t\nfunction smoothLerp(min, max, v, amount) {\n    t = smoothstep(v)\n  //  t=(t*amount)/t\n    return (max * t) + (min * (1 - t))\n}\nfunction smoothstep(x) {\n    return x * x * (3 - 2 * x);\n}\n//var triggers,triggers_step\nvar targets,allow_render, args\nasync function animate() {\n    finished=[]\n    lerp_registry.activelist.map((val, index) => {\n        //checking if the element is finished and needs to be deleted\n        if (lerp_registry.progress[val] <= lerp_registry.duration[val]) {\n            //waiting for delay\n            if (lerp_registry.delay_delta[val] < lerp_registry.delay[val]) {\n                lerp_registry.delay_delta[val] += 1\n            }\n            else {\n                allow_render=lerp_registry.progress[val] % lerp_registry.render_interval[val] \n                if (allow_render == 0) {\n                    lerp_registry.delta_t[val] = lerp_registry.progress[val] / lerp_registry.duration[val];\n                    switch(lerp_registry.type[val]){\n                        case(2):\n                        lerp_registry.results.set(val, smoothLerp(\n                                lerpChain_registry.buffer[lerp_registry.lerp_chain_start[val]+lerpChain_registry.progress[val]],\n                                lerpChain_registry.buffer[lerp_registry.lerp_chain_start[val]+lerpChain_registry.progress[val]+1],\n                                lerp_registry.delta_t[val] ,\n                                lerp_registry.smoothstep[val]\n                            ))\n                            break\n                        case(3):\n                            for (let i=0;i< lerpChain_registry.matrixChains.get(val).get(lerpChain_registry.progress[val]).length;i++)\n                            {\n                                lerp_registry.results.get(val)[i]= smoothLerp(\n                                    lerpChain_registry.matrixChains.get(val).get(lerpChain_registry.progress[val])[i],\n                                    lerpChain_registry.matrixChains.get(val).get(lerpChain_registry.progress[val]+1)[i],\n                                    lerp_registry.delta_t[val] ,\n                                    lerp_registry.smoothstep[val]\n                                )\n                            }\n                            break;\n                        default:\n                            return console.error(\"wrong type\"+String(val));\n                    }\n                   args={id:val,value:lerp_registry.results.get(val),step:lerpChain_registry.progress[val], time:lerp_registry.progress[val] ,step:lerpChain_registry.progress[val]} //time war vorther lerp_registry.delta_t[val]\n                   if(callback_registry.condition.has(val)&&(callback_registry.condition.get(val)||callback_registry.condition.get(val)(args)==true)) {\n                     callback_registry.callback.get(val)(args)\n                   }\n                }\n                lerp_registry.progress[val] += 1\n                if (allow_render==0) {\n                    triggers_step=trigger_registry.get(val)!=undefined?trigger_registry.get(val).get(lerpChain_registry.progress[val]):undefined\n                    if ( triggers_step != undefined) {\n                        targets= triggers_step.get(lerp_registry.progress[val]-1)\n                        targets&&targets.map((target)=>{\n                            lerpChain_registry.soft_reset(target)\n                        })\n                    }\n                }\n            }\n        } \n        else {\n            if(lerp_registry.lerp_chain_start[val]!=undefined&&lerpChain_registry.update_progress(val)==true){\n                finished.push(val);\n            }\n        }\n    })\n    return finished\n}\n//t = callback_registry.callback.get(val)?.(val, t) ?? undefined; //  Null-Coalescing-Operator -- if callback not undefined then use and process the value t for callback\n// const eslapsed = performance.now() - startTime;\n// const waitTime = Math.max(0, fps - elapsed);\nvar startTime \nfunction animateLoop() {\n    if(status==true){\n     \n      startTime = performance.now();\n      \n      finished = []\n      if (lerp_registry.activelist.length > 0) {\n        animate().then(finished=>{\n          render()\n          if (finished.length > 0) {\n            lerp_registry.activelist = lerp_registry.activelist.filter((active) => !finished.includes(active));\n            if (lerp_registry.activelist[\"length\"] == 0) {\n              loop_resolver =null\n            }\n          }\n          sleep(Math.max(0, fps - (performance.now() - startTime))).then(()=>{\n            if(status==true){\n            animateLoop()\n        }else{\n            loop_resolver(\"stopping\")\n            loop_resolver = null\n            lerp_registry.activelist=[]  \n                     }\n\n        })\n        \n        })\n      }\n  }else if(loop_resolver!=null){\n        loop_resolver(\"stopping\")\n        loop_resolver = null\n  }\n  }\n// postMessage({\n//     message: \"finish\",\n//     results: lerp_registry.results,\n//     result_indices: lerp_registry.activelist\n// });\nfunction start_loop() {\n    status=true\n    if(loop_resolver==null){\n        \n        new Promise((resolve, reject) => {\n            loop_resolver=reject\n            animateLoop()\n            resolve()\n    }).catch((error) => {\n        //console.warn(\"Error in animateLoop:\", error);\n        loop_resolver = null;\n        \n    });\n    }\n}\nasync function stop_loop() {\n    status=false\n  if(loop_resolver!=null){\n        loop_resolver(\"stopping\")\n    }    \n}\nfunction start_animations(indices){\n    indices.map((id)=>{\n        lerpChain_registry.soft_reset(id)\n    })\n    start_loop()\n}\nfunction stop_animations(indices){\n    if(indices===\"all\"){\n        lerp_registry.activelist=[]\n        stop_loop()\n    }\n    else{\n        indices.map((id)=>{\n            if(lerp_registry.activelist.includes(id)){\n                lerp_registry.activelist=lerp_registry.activelist.filter((x)=>x!=id)\n            }\n        })\n    }\n    if (lerp_registry.activelist.length == 0) {\n        stop_loop()\n    } \n}\nasync function reset_animations(indices){\n    if(indices==\"all\"){stop_loop();indices=lerp_registry.activelist}\n    //stop_animations(indices)\n    const stopped=[]    \n    indices.map((x)=>{\n        lerpChain_registry.reset(x);\n        lerp_registry.activate(x)\n        if(lerp_registry.activelist.includes(x)==false || loop_resolver==null){\n            stopped.push(x)\n            switch(lerp_registry.type[x]){\n                case(2):\n                    lerp_registry.results.set(x,lerpChain_registry.buffer[lerp_registry.lerp_chain_start[x]])\n                    break\n                case(3):\n                    lerp_registry.results.set(x,lerpChain_registry.matrixChains.get(x).get(0))\n                    break\n                default:break;\n        }\n    }\n    })\n    if(stopped.length>0) postMessage({ message: \"render\", results: lerp_registry.results, result_indices: indices })\n}\nfunction change_framerate(fps_new) { fps = fps_new }\nconst integers = [\"loop\",\"delay\",\"type\",\"progress\",\"duration\",\"render_interval\",\"lerp_chain_start\",\"activelist\"]\nfunction init(lerps, lerpChains, matrixChains, triggers, constants, condi_new, lambdas, springs) {\n    triggers.forEach((trigger,key)=>trigger_registry.set(key,trigger))\n    condi_new.forEach((val,key)=>{\n          callback_registry.callback.set(key,eval(val.callback))\n          callback_registry.condition.set(key,eval(val.condition))\n    })\n    lambdas.forEach((val,key)=>{\n        lambda_registry.callback.set(key,eval(val.callback))\n        lambda_registry.condition.set(key,eval(val.condition))\n    })\n    lerpChains.forEach((arr,name)=>{\n            lerpChain_registry[name]=new Float32Array(arr)\n          //  console.log(lerpChain_registry[name])\n    })\n    lerpChain_registry.matrixChains=matrixChains\n    lerps.forEach((array, name) => {\n            if(integers.includes(name)==false ){\n                lerp_registry[name] = new Float32Array(array)\n            }\n            else{lerp_registry[name] = new Uint8Array(array)}\n    })\n    if(constants.get(\"matrix\")!=undefined){\n        constants.get(\"matrix\").forEach((val,i)=>{\n            constant_registry.matrix.set(i,new Map())\n            val.map((m,i2)=>{constant_registry.matrix.get(i).set(i2,new Float32Array(m))})\n        })\n    }\n    if(constants.get(\"number\")!=undefined){\n        constant_registry.number=constants.get(\"number\")\n    }\n    lerp_registry.type.map((t,i)=>{\n        //  TODO hier zur vereinfachung interne get funktionen nehmen\n        if(t==2){\n            lerp_registry.results.set(i,lerpChain_registry.buffer[lerp_registry.lerp_chain_start[i]])\n        }\n        else{\n            lerp_registry.results.set(i,new Float32Array(lerpChain_registry.matrixChains.get(i).get(0)))\n        }\n    })\n    lerp_registry.delta_t=new Float32Array(lerp_registry.duration.length)\n    lerp_registry.delay_delta=new Float32Array(lerp_registry.duration.length)\n}\nfunction addTrigger(id,target,step,time){\n    var trigger = []\n    if(trigger_registry.get(id)==undefined){\n        trigger_registry.set(id,new Map())\n    }\n    if(trigger_registry.get(id).get(step)==undefined){\n        trigger_registry.get(id).set(step, new Map())\n        trigger_registry.get(id).get(step).set(time,new Uint8Array([target]))\n    }\n    else if(trigger_registry.get(id).get(step).get(time)==undefined){\n        trigger_registry.get(id).get(step).set(time,new Uint8Array([target]))\n    }\n    else{\n        trigger=trigger_registry.get(id).get(step).get(time)\n        if(trigger.includes(target)==false){\n            var newtriggers=new Array(trigger)\n            newtriggers.push(target)\n            newtriggers= new Uint8Array(newtriggers)\n            trigger_registry.get(id).get(step).set(time,newtriggers)\n        }\n        else{\n            console.warn(`trigger already exists: target ${target} in timeframe ${time} in step ${step} on animation with id ${id}`)\n        }   \n    }\n}\nfunction removeTrigger(id,target,step,time){\n    var trigger=trigger_registry.get(id).get(step)\n    if(trigger!=undefined){\n        if(trigger.get(time)!=undefined){\n            trigger=trigger.get(time)\n        }\n        else{\n            return(console.warn(\"the slected timeframe in the  step does not include the target\"))\n        }\n    }\n    else{\n        return(console.warn(\"the trigger registr has does not include the step\"))\n    }\n    const targetId=trigger.indexOf(target)\n    if(targetId!=undefined&&trigger.length>1){\n        const newtriggers= new Uint8Array(new Array(trigger).splice(targetId,1))\n        console.log(`removed trigger target ${target} in timeframe ${time} in step ${step} from from id ${id}`)\n        trigger_registry.get(id).get(step).set(time,newtriggers)\n    }\n    else {\n        trigger_registry.get(id).get(step).set(time,undefined)\n    }\n    // else{\n    //     trigger_registry.get(id).set(step,undefined)\n    // }\n}\nfunction update(type,values){\n    values.map((x)=>{\n        if(lerpChain_registry.lengths[x.id]!=x.values.length-1){\n            console.log(trigger_registry.get(x.id))\n            if(lerp_registry.loop[x.id]==1){\n            removeTrigger(x.id,x.id,lerpChain_registry.lengths[x.id]-1,lerp_registry.duration[x.id])\n            addTrigger(x.id,x.id,x.values.length-2,lerp_registry.duration[x.id])\n            //trigger_registry.get(x.id).set(lerpChain_registry.lengths[x.id]-1,undefined)\n        }\n        lerpChain_registry.lengths[x.id]=x.values.length-1\n        }\n        if(type==2){\n            x.values.map((val,i)=>{\n                lerpChain_registry.buffer[lerp_registry.lerp_chain_start[x.id]+i]=val\n            })\n        }\n        else if(type==3){\n            x.values.map((val,i)=>{\n                lerpChain_registry.matrixChains.get(x.id).set(i,val)\n            })\n        }\n        lerpChain_registry.reset(x.id)\n    })\n}\nvar lambda // <- just for debugging\nfunction lambda_call(id,args){\n    if (lambda_registry.condition.get(id) ==undefined || lambda_registry.condition.get(id)){\n       lambda= lambda_registry.callback.get(id)\n       lambda(args)\n    } \n}\n// ----------------------------------------> EVENTS <--\nasync function render() {\n    if(status==true)  postMessage({ message: \"render\", results: lerp_registry.results, result_indices: lerp_registry.activelist })\n}\nasync function render_constant(id,type) {\n    postMessage({ message: \"render_constant\", id:id, type: type, value:  get_constant(id,type)})\n}\nfunction returnPromise(promise) {\n    postMessage({ message: \"stopping\", promise:promise }) ;\n\n}\nonmessage = (event) => {\n    switch (event.data.method) {\n        case 'init':\n            init(event.data.data, event.data.chain_map, event.data.matrix_chain_map, event.data.trigger_map, event.data.constants, event.data.callback_map, event.data.lambda_map,event.data.spring_map,);\n            break;\n        case \"update\":\n            update(event.data.type,event.data.data)\n            break\n        case 'update_constant':\n            constant_registry.update(event.data.type, event.data.id,event.data.value);\n            break;\n        case 'start':\n            start_loop();\n            break;\n        //makes no sense since we would require a promise on the mainthread\n        //this is shitty, cause you have to have a list of promises\n        //however the user can still use get_active on the worker via callbacks, or lambdas\n        // case 'get_active':\n        //     postMessage({ message: \"get_active\", active:lerp_registry.activelist})\n        //     break;\n        case 'stop':\n            stop_loop()\n            break;\n        case 'change_framerate':\n            change_framerate(event.data.fps_new);\n            break;\n        case 'lambda_call':\n            lambda_call(event.data.id,event.data.args);\n            break;\n        case 'start_animations':\n            start_animations(event.data.indices);\n            break;\n        case 'stop_animations':\n            if(status==true) {\n                status=false\n                stop_animations(event.data.indices);\n            }\n            \n            break;\n        case 'reset_animations':\n            reset_animations(event.data.indices);\n            break;\n        case 'addTrigger':\n            addTrigger(event.data.id,event.data.target,event.data.step,event.data.time);\n            break;\n        case 'removeTrigger':\n            removeTrigger(event.data.id,event.data.target,event.data.step,event.data.time);\n            break;\n        default:\n            console.warn(\"no method selected during worker call\")\n            break\n    }\n};\nfunction setLerp(index,step,value){\n    //console.log(lerpChain_registry.buffer[lerp_registry.lerp_chain_start[index]+step])\n    lerpChain_registry.buffer[lerp_registry.lerp_chain_start[index]+step]=value\n}\nfunction setMatrix(index,step,value){\n   // console.log(lerpChain_registry.matrixChains.get(index).get(step))\n    value.map((x,i) => {\n        lerpChain_registry.matrixChains.get(index).get(step)[i]=x\n    })\n   // lerpChain_registry.matrixChains.get(index).get(step)\n}\nfunction update_constant(id,type,value){constant_registry.update(type,id,value)}\nfunction get_constant(id,type){return constant_registry.get(type,id)}\nfunction get_time(id){return lerp_registry.progress[id]}\nfunction is_active(id){return lerp_registry.activelist.includes(id)}\nfunction current_step(id){return lerpChain_registry.progress(id)}\nfunction get_lerp_value(id){return lerp_registry.results.get(id)}\nfunction soft_reset(id){lerpChain_registry.soft_reset(id)}\nfunction hard_reset(id){lerpChain_registry.reset(id)}\nfunction set_delta_t(id,val){lerp_registry.progress=val;lerp_registry.delta_t[id]=lerp_registry.duration[id]/lerp_registry.progress[id]}\nfunction set_step(id,val){lerpChain_registry.progress[id]=val>lerpChain_registry.lengths[id]?lerpChain_registry.lengths[id]:val}\nfunction get_duration(id){return lerp_registry.duration[id]}\nfunction set_duration(id,val){lerp_registry.duration[id]=val}\nfunction get_delay(id){return lerp_registry.delay[id]}\nfunction set_delay(id,val){lerp_registry.delay[id]=val}\nfunction get_delay_delta(id){return lerp_registry.delay_delta[id]}\nfunction set_delay_delta(id,val){lerp_registry.delay_delta[id]=val}\nfunction set_sequence_length(id,val){lerpChain_registry.lengths[id]=val}\nfunction get_constant_row(id,row){return constant_registry.get_row(id,row)}\nfunction get_constant_number(id){return constant_registry.get_number(id)}\nfunction get_active(id){return lerp_registry.activelist}\nfunction get_status(){\n    return status\n}\n\nexport {\n    get_status,\n    addTrigger,removeTrigger,\n    get_time,set_delta_t,\n    current_step,set_step,\n    is_active,get_active,\n    start_animations,stop_animations,\n    setLerp,setMatrix,\n    get_lerp_value,\n    soft_reset,hard_reset,\n    get_duration,set_duration,\n    set_sequence_length,\n    change_framerate,\n    get_constant,get_constant_number,get_constant_row,render_constant,\n    update_constant,\n    set_delay,get_delay,\n    get_delay_delta,set_delay_delta,\n    lambda_call\n}\n\n// ----------------------------------------> REQUIRES IMPLEMENTATION <--\n\nclass Spring{\n    constructor(elements,duration,spring_tension,spring_whatever,){\n            this.elements=elements\n            this.duration=duration\n            this.spring_tension=spring_tension\n    \n    }\n    }\n//dijkstra algo für matrix\nfunction shortest_path(){\n\n}\n// k nearest neigbor for matrix (not sure if also for lerp)\nfunction knn(){\n\n}\n//matrix and callback for lerp\nfunction convex_hull(){\n\n}\nfunction spring(){\n\n}\n// function triggers() {\n//     postMessage({ message: \"trigger\", results: lerp_registry.results, result_indices: lerp_registry.activelist })\n// }\n\n\n//v = Math.floor(registry.progress[val] / registry.duration[val]);\n\n\n\n// function calculateSpringAnimation(matrix, params) {\n//     const { mass, tension, friction, bounce, damping, decay, duration, velocities } = params;\n  \n//     return matrix.map((value, index) => {\n//       const initialValue = value;\n//       const targetValue = params.targetValues ? params.targetValues[index] : initialValue;\n      \n//       const k = 2 * Math.PI * Math.sqrt(tension / mass);\n//       const zeta = damping / (2 * mass);\n//       const omega = k * Math.sqrt(1 - zeta * zeta);\n  \n//       return (t) => {\n//         const x = targetValue - initialValue;\n//         const theta = omega * t;\n  \n//         let y;\n//         if (zeta < 1) {\n//           // Unter- oder kritisch gedämpft\n//           y = x * Math.exp(-zeta * theta) * (Math.cos(theta) + (zeta / omega) * Math.sin(theta));\n//         } else {\n//           // Überdämpft\n//           y = x * Math.exp(-omega * t);\n//         }\n  \n//         // Bounce-Effekt hinzufügen\n//         const bounceFactor = Math.pow(0.9, t / duration);\n//         y *= bounceFactor;\n  \n//         // Auslaufwert berücksichtigen\n//         return targetValue + (y - targetValue) * Math.exp(-decay * t);\n//       };\n//     });\n//   }\n  \n//   // Beispielaufruf:\n//   const matrix = [10, 20, 30, 40, 50];\n//   const params = {\n//     mass: 0.5,\n//     tension: 100,\n//     friction: 0.05,\n//     bounce: 0.9,\n//     damping: 0.15,\n//     decay: 0.001,\n//     duration: 1000,\n//     velocities: [0, 0, 0, 0, 0],\n//     targetValues: [15, 25, 35, 45, 55]\n//   };\n  \n//   const animations = calculateSpringAnimation(matrix, params);\n  "],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","finished","fps","signal","loop_resolver","triggers_step","status","final_step","final_sub_step","async","sleep","milliseconds","Promise","resolve","setTimeout","Lerp","constructor","this","type","undefined","delta_t","duration","render_interval","delay_delta","delay","progress","smoothstep","lerp_chain_start","loop","activelist","results","Map","activate","id","includes","push","index","LerpChain","buffer","matrixChains","lengths","update_progress","reset_and_update","lerp_registry","reset","set","lerpChain_registry","soft_reset","Callback","callback","condition","Constant","matrices","numbers","matrix","number","update","value","constant_registry","row","get_row","get_number","callback_registry","lambda_registry","trigger_registry","t","targets","allow_render","args","startTime","smoothLerp","min","max","v","amount","x","animate","map","val","i","length","console","error","String","step","time","has","target","animateLoop","performance","now","then","render","filter","active","Math","start_loop","reject","catch","stop_loop","start_animations","indices","stop_animations","reset_animations","stopped","postMessage","message","result_indices","change_framerate","fps_new","integers","init","lerps","lerpChains","triggers","constants","condi_new","lambdas","springs","forEach","trigger","eval","arr","name","Float32Array","array","Uint8Array","m","i2","addTrigger","newtriggers","Array","warn","concat","removeTrigger","targetId","indexOf","splice","log","values","lambda","lambda_call","render_constant","get_constant","returnPromise","promise","setLerp","setMatrix","update_constant","get_time","is_active","current_step","get_lerp_value","hard_reset","set_delta_t","set_step","get_duration","set_duration","get_delay","set_delay","get_delay_delta","set_delay_delta","set_sequence_length","get_constant_row","get_constant_number","get_active","get_status","onmessage","event","data","method","chain_map","matrix_chain_map","trigger_map","callback_map","lambda_map","spring_map","Spring","elements","spring_tension","spring_whatever","shortest_path","knn","convex_hull","spring"],"sourceRoot":""}